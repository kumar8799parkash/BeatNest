üåç 1. What is CORS?

CORS = Cross-Origin Resource Sharing.
It‚Äôs a security mechanism built into browsers to control how a web page (frontend) can request resources (API, data, images, etc.) from a different origin.


2. What is an "Origin"?

Origin = combination of protocol + domain (or IP) + port.

Examples:

http://localhost:3000 ‚Üí origin = http + localhost + 3000

http://localhost:5000 ‚Üí origin = http + localhost + 5000

https://beatnest.com ‚Üí origin = https + beatnest.com + 443

üëâ Even if domain is same but port is different, it‚Äôs a different origin!
So:

http://localhost:3000 and http://localhost:5000 ‚Üí different origins ‚ùå

https://beatnest.com and http://beatnest.com ‚Üí different origins ‚ùå

https://beatnest.com/api and https://beatnest.com/home ‚Üí same origin ‚úÖ (path doesn‚Äôt matter)





3. Why does CORS create problems?

Browsers block cross-origin requests by default, because otherwise:

A malicious website could secretly call your APIs, steal data, or impersonate users.

Example: Imagine you‚Äôre logged into bank.com. If CORS didn‚Äôt exist, a malicious site hacker.com could run:

fetch("https://bank.com/transfer?to=hacker&amount=1000")


üò± and your money is gone.

So, CORS prevents websites from calling APIs unless the server explicitly allows it.





4. How CORS works (Mechanism)

When frontend calls a backend on a different origin:

Browser first sends a CORS preflight request (an OPTIONS request).

‚ÄúHey server, can I call you from this origin?‚Äù

Server must respond with proper CORS headers, e.g.:

Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization


If the headers match ‚Üí browser allows the actual request.
If not ‚Üí browser blocks the request, and you see error in console:
‚ùå Access to fetch at 'http://localhost:5000/signup' from origin 'http://localhost:3000' has been blocked by CORS policy







‚úÖ 5. How to Fix CORS in Express

That‚Äôs why we use the cors middleware in Express:

Step 1: Install
npm install cors

Step 2: Use in backend
const cors = require("cors");

// Allow all origins (for dev)
app.use(cors());

// Or allow only specific origin
app.use(cors({
  origin: "http://localhost:3000",   // allow only frontend on 3000
  methods: ["GET", "POST"],
  allowedHeaders: ["Content-Type", "Authorization"]
}));







üèóÔ∏è 6. Different Use Cases of CORS
Case A: Development (different ports)

Frontend: http://localhost:3000

Backend: http://localhost:5000

Fix: use app.use(cors({ origin: "http://localhost:3000" }))

Case B: Production (different domains)

Frontend: https://beatnest.com

Backend: https://api.beatnest.com

Fix:

app.use(cors({
  origin: "https://beatnest.com"
}));

Case C: Public API

If you want anyone in the world to use your API (like weather API):

app.use(cors({ origin: "*" }));   // allow all origins


‚ö†Ô∏è But not safe if sensitive data is involved.

Case D: Private API

If only your own frontend should access backend:

app.use(cors({
  origin: ["https://beatnest.com", "https://admin.beatnest.com"]
}));




JSON.STRINGIFY() FUNCTION : When you send data with fetch, the body must be a string (or certain formats like FormData, Blob, etc.).
                            But in JS, { email, password } is an object, not a string.
    { email: "test@gmail.com", password: "12345" }
    ‚Üì JSON.stringify()
    '{"email":"test@gmail.com","password":"12345"}'


üîπ WHAT IS "APPLICATION/JSON" IN HEADERS?

This is the Content-Type header.
It tells the server what format the request body is in.

"application/json" ‚Üí The body is JSON.

"text/plain" ‚Üí The body is plain text.

"application/x-www-form-urlencoded" ‚Üí Form data (like HTML forms).

"multipart/form-data" ‚Üí Used when uploading files.

So in your code:

headers: { "Content-type": "application/json" }


means ‚Üí ‚ÄúHey server, I‚Äôm sending JSON data. Please parse it as JSON.‚Äù





HOW SERVER HANDLES DIFFERENT CONTENT-TYPES : USING MIDDLEWARES
      app.use(express.json());          If it‚Äôs "application/json", it automatically parses the body string back into a JS object.



      What this line actually does
          This is a middleware in Express.
          Middlewares in Express run for every request (GET, POST, PUT, DELETE, etc.) that passes through your server.
          So yes ‚Üí every request passes through this middleware before reaching your route handler.


    üîπ Why do we need it?
          When a request comes in with a JSON body (like your fetch(..., { method: "POST", body: JSON.stringify(...) })), the raw body is just a stream of bytes.
          Without express.json(), if you console.log(req.body), you‚Äôd get undefined because Express doesn‚Äôt parse the body automatically.
          app.use(express.json()); says:
          ‚ÄúWhenever a request has Content-Type: application/json, read the body, parse the JSON, and put the result into req.body.‚Äù




Different Content-Types need different parsers/middlewares on the server side. Let‚Äôs go over the most common ones:


    1. application/json

Use case: APIs sending/receiving structured data.

Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ email: "abc@gmail.com", password: "123" })
});


Server:

app.use(express.json()); // parses JSON into req.body




2. application/x-www-form-urlencoded

Use case: Classic HTML forms (<form method="POST">).

Body looks like:

email=abc%40gmail.com&password=123


Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/x-www-form-urlencoded" },
  body: "email=abc@gmail.com&password=123"
});


Server:

app.use(express.urlencoded({ extended: true }));






3. multipart/form-data

Use case: File uploads (images, audio, video).

Body: Binary + text mixed together in parts.

Client:

const formData = new FormData();
formData.append("username", "abc");
formData.append("profilePic", fileInput.files[0]);

fetch("/upload", { method: "POST", body: formData });


(‚ö†Ô∏è Don‚Äôt set Content-Type manually ‚Üí browser will set boundary automatically.)

Server: Needs a parser like multer, not express.json().




4. text/plain

Use case: Sending raw text.

Client:

fetch("/notes", {
  method: "POST",
  headers: { "Content-Type": "text/plain" },
  body: "This is a plain text note"
});


Server: Use express.text() middleware.



üîπ 5. Others (less common but important)

application/xml ‚Üí XML data (used in legacy APIs).

application/octet-stream ‚Üí Raw binary (files, audio chunks).

application/pdf / image/png ‚Üí Specific file types.






// req and res BUILT-IN OBJECTS IN JS

Exactly üëç ‚Äî you didn‚Äôt define req and res yourself, Express gives them to you automatically.

Let me break it down:


üîπ What are req and res?

When a client (browser, Postman, fetch, etc.) makes a request to your server, Express creates two special objects for you:

req (Request object) ‚Üí Contains everything about the incoming request.

URL
HTTP method (GET, POST, etc.)
Headers
Body (if any)
Query params (?id=123)
Cookies, etc.


res (Response object) ‚Üí Used to send a response back to the client.

res.send() ‚Üí send plain text or HTML
res.json() ‚Üí send JSON
res.status(404).send("Not Found") ‚Üí send status + message
res.redirect() ‚Üí redirect to another URL



üîπ Where do they come from?

Your code:

app.get('/', (req, res) => {
  res.send('Hello World! he he!')
});


Behind the scenes:
    Express sits on top of Node.js‚Äôs HTTP module.
    When a request comes in, Node creates a low-level IncomingMessage (req) and ServerResponse (res).
    Express wraps those in its own Request and Response objects (with extra helpful methods like .json(), .status(), etc.).
    Then, Express passes them to your route handler automatically.
    That‚Äôs why you don‚Äôt need to create req or res ‚Äî they‚Äôre given to your callback.


app.get('/user', (req, res) => {
  console.log(req.method);   // "GET"
  console.log(req.url);      // "/user"
  
  res.status(200).json({ message: "User found!" });
});

req.method ‚Üí comes from the HTTP request.
res.status(200).json(...) ‚Üí Express convenience function to send status + JSON.




FIRST: WHAT IS NODEMAILER VS. TRANSPORT?

Nodemailer = the library (the "engine") that lets you send emails from Node.js.
Transport = the "delivery method" (the "vehicle") Nodemailer uses to actually send the email.
Think of it like

Nodemailer = the post office system (handles packaging, addressing, tracking).
Transport = the mail truck, airplane, or courier service that physically delivers the letter.

So when you use Nodemailer, you always have to pick a transport.

üîπ TYPES OF TRANSPORTS IN NODEMAILER : Transport flexibility ‚Äî SMTP, sendmail, Amazon SES, direct transport, or plugins






DIFFERENCE BETWEEN CRYPTO AND BCRYPT

1. What is crypto?

crypto is a built-in Node.js module (no installation needed).
It provides general-purpose cryptographic functionality like:

Hashing (sha256, sha512, etc.)
Symmetric encryption/decryption (AES, DES, etc.)
Asymmetric encryption (RSA, ECDSA, etc.)
Random value generation

It is fast but not designed specifically for password hashing.
PROBLEM FOR PASSWORDS:
These hashes are deterministic and very fast, so attackers can brute-force millions of guesses per second with precomputed rainbow tables. Not secure for password storage.



üîπ 2. What is bcrypt?

bcrypt is a library (must install: npm install bcrypt).
It is designed specifically for password hashing.

Uses:
Salting (random string added before hashing) ‚Üí prevents rainbow table attacks.
Key stretching (work factor/cost) ‚Üí intentionally slow hashing ‚Üí makes brute-force expensive.



1.1 HASHING FUNCTIONS

üëâ USED FOR DATA INTEGRITY (NOT PASSWORD STORAGE).

import crypto from "crypto";

// SHA-256 hash
const sha256Hash = crypto.createHash("sha256")
  .update("HelloWorld")
  .digest("hex");

console.log("SHA-256 Hash:", sha256Hash);

createHash(algorithm) ‚Üí algorithm can be "sha256", "sha512", etc.
update(data) ‚Üí add data to hash.
digest("hex" | "base64") ‚Üí finalize hash and get result.
‚úÖ Use: File integrity check, digital signatures, API signing.


1.2 HMAC (HASH-BASED MESSAGE AUTHENTICATION CODE)

const secret = "mySecretKey";

const hmac = crypto.createHmac("sha256", secret)
  .update("HelloWorld")
  .digest("hex");

console.log("HMAC:", hmac);

‚úÖ Use: JWT signing, API request signing, ensuring data authenticity.



1.3 RANDOM BYTES

const token = crypto.randomBytes(32).toString("hex");
console.log("Random Token:", token);

‚úÖ Use: Session IDs, password reset tokens, email verification codes.


1.4 SYMMETRIC ENCRYPTION (AES EXAMPLE)

üëâ Encrypt and decrypt data with the same key.

const key = crypto.randomBytes(32);   // 256-bit key
const iv = crypto.randomBytes(16);    // Initialization vector

// Encrypt
const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
let encrypted = cipher.update("HelloWorld", "utf8", "hex");
encrypted += cipher.final("hex");
console.log("Encrypted:", encrypted);

// Decrypt
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");
console.log("Decrypted:", decrypted);

‚úÖ Use: Encrypting sensitive data (files, messages).


1.5 KEY PAIR (ASYMMETRIC RSA/ECDSA)

üëâ Used for public/private key encryption.

const { generateKeyPairSync } = crypto;

const { publicKey, privateKey } = generateKeyPairSync("rsa", {
  modulusLength: 2048,
});

console.log("Public Key:", publicKey.export({ type: "pkcs1", format: "pem" }));
console.log("Private Key:", privateKey.export({ type: "pkcs1", format: "pem" }));

‚úÖ Use: Digital signatures, SSL/TLS, JWT with RSA.




üîπ 2. BCRYPT (PASSWORD HASHING LIBRARY)

Unlike crypto, bcrypt is only for password hashing.
It‚Äôs slow + salted, making brute force attacks harder.


2.1 HASH A PASSWORD

üëâ Always store passwords hashed.

import bcrypt from "bcrypt";

const password = "mypassword";
const saltRounds = 10;

const hash = await bcrypt.hash(password, saltRounds);
console.log("Hashed Password:", hash);

bcrypt.hash(password, saltRounds)
saltRounds = cost factor (higher = slower = more secure).
‚úÖ Use: Store hashed password in DB.


2.2 VERIFY A PASSWORD

üëâ Compare user input with stored hash.

const isMatch = await bcrypt.compare("mypassword", hash);
console.log("Password Match:", isMatch); // true

‚úÖ Use: Login authentication.


2.3 GENERATE SALT MANUALLY

üëâ You can generate salt separately.

const salt = await bcrypt.genSalt(12);
const hash2 = await bcrypt.hash("mypassword", salt);

console.log("Salt:", salt);
console.log("Hash with salt:", hash2);

‚úÖ Use: More control if you want to manage salt rounds explicitly.

2.4 CHANGE SALT ROUNDS FOR SECURITY

üëâ Increasing rounds makes hashing slower but more secure.

const hashFast = await bcrypt.hash("mypassword", 8);  // faster
const hashSlow = await bcrypt.hash("mypassword", 15); // slower, more secure

console.log("Fast Hash:", hashFast);
console.log("Slow Hash:", hashSlow);

‚úÖ Use: Adjust performance vs security tradeoff.





EXPRESS RESPONSE METHODS

1. res.status(code)

  Sets the HTTP status code (like 200 OK, 400 Bad Request, 404 Not Found, 500 Server Error, etc.).
  Usually chained with another method like .send(), .json(), .end().
  Use case: Always when you want to indicate success/failure explicitly.

res.status(404).send("Not Found");


2. res.send([body])

Sends a response body of any type (string, object, array, buffer, HTML).
If you pass an object/array, Express automatically converts it to JSON.
If you pass a string, it sends plain text/HTML.

res.send("Hello World");         // plain text
res.send("<h1>Hello</h1>");      // HTML response
res.send({ user: "Jarvis" });    // JSON automatically

Use case: When you want flexibility (text, HTML, JSON).



3. res.json(obj)

Sends a JSON response.
Automatically sets Content-Type: application/json.

Useful for APIs.

res.json({ success: true, data: [1, 2, 3] });

Use case: REST APIs or AJAX calls from frontend.



4. res.sendFile(path)

Sends a file as the response.
Example: Serving images, PDFs, or downloadable files.

res.sendFile("/absolute/path/to/image.png");

Use case: File downloads, serving static files dynamically.




5. res.download(path, [filename])

Forces the browser to download a file instead of displaying it.
Optional filename lets you rename it.

res.download("/files/report.pdf", "user-report.pdf");

Use case: Letting users download generated files.




6. res.redirect([status,] url)

Redirects the client to another URL.
Default status is 302 (Found ‚Üí temporary redirect).

res.redirect("/login");           // 302 redirect
res.redirect(301, "/new-page");   // permanent redirect

Use case: After logout, redirecting users to /login.



7. res.end([data])

Ends the response process immediately.
Can send optional data (like raw strings/buffers).

res.end();             // just end response
res.end("Done!");      // end with message

Use case: Low-level response finishing, no content needed.



8. res.render(view, [locals])

Used with template engines (like EJS, Pug, Handlebars).
Renders HTML from a template.

res.render("profile", { username: "Jarvis" });

Use case: Server-side rendered apps.



9. res.set(field, value)

Sets a custom header.

res.set("X-Powered-By", "Jarvis");
res.status(200).send("Header set!");

Use case: Custom metadata (security headers, caching, API versioning).



10. res.cookie(name, value, [options]) & res.clearCookie(name)

Send or clear cookies with the response.

res.cookie("token", "12345", { httpOnly: true });
res.clearCookie("token");

Use case: Session handling, authentication.



HELMET PACKAGE : The Helmet package is a security middleware for Express.js applications. Its main purpose is to help protect 
                 your app from common web vulnerabilities by setting secure HTTP headers automatically.


Sets Secure HTTP Headers

It configures headers like:

Content-Security-Policy (CSP) ‚Üí Prevents cross-site scripting (XSS) and other code injection attacks.
X-Frame-Options ‚Üí Prevents clickjacking by disallowing embedding of your site in iframes.
Strict-Transport-Security (HSTS) ‚Üí Forces HTTPS connections.
X-Content-Type-Options ‚Üí Prevents browsers from guessing ("sniffing") content types.
X-DNS-Prefetch-Control ‚Üí Controls DNS prefetching.
X-Permitted-Cross-Domain-Policies ‚Üí Restricts Adobe Flash/Acrobat cross-domain policies.
Referrer-Policy ‚Üí Controls how much referrer info is shared.
Cross-Origin-Embedder-Policy, Cross-Origin-Opener-Policy, Cross-Origin-Resource-Policy ‚Üí Strengthen isolation and mitigate cross-origin leaks



Explanation of some Helmet headers (with examples)

X-Frame-Options: SAMEORIGIN:
Prevents your site from being loaded in an iframe on another site (stops clickjacking attacks).
Example: If an attacker tries to embed your banking site in their page and trick you into clicking ‚ÄúTransfer money‚Äù, this header blocks it.

X-Content-Type-Options: nosniff:
Prevents browsers from guessing file types.
Example: If your server says a file is text/plain, but it actually contains JavaScript, the browser won‚Äôt execute it. This prevents some XSS attacks.

Strict-Transport-Security:
Forces all future requests to use HTTPS, not HTTP.
Example: If someone types http://example.com, the browser will auto-upgrade to https://example.com.

Referrer-Policy: no-referrer:
Controls how much referrer info is shared when a user clicks a link.
Example: If you visit mybank.com, and then click a link to evil.com, your bank URL won‚Äôt be leaked as the referrer.

Content-Security-Policy (CSP):
Controls what kind of content (scripts, images, styles) can load on your site.
Example: You can allow scripts only from your own domain (self), blocking malicious scripts injected from others.