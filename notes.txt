üåç 1. What is CORS?

CORS = Cross-Origin Resource Sharing.
It‚Äôs a security mechanism built into browsers to control how a web page (frontend) can request resources (API, data, images, etc.) from a different origin.


2. What is an "Origin"?

Origin = combination of protocol + domain (or IP) + port.

Examples:

http://localhost:3000 ‚Üí origin = http + localhost + 3000

http://localhost:5000 ‚Üí origin = http + localhost + 5000

https://beatnest.com ‚Üí origin = https + beatnest.com + 443

üëâ Even if domain is same but port is different, it‚Äôs a different origin!
So:

http://localhost:3000 and http://localhost:5000 ‚Üí different origins ‚ùå

https://beatnest.com and http://beatnest.com ‚Üí different origins ‚ùå

https://beatnest.com/api and https://beatnest.com/home ‚Üí same origin ‚úÖ (path doesn‚Äôt matter)





3. Why does CORS create problems?

Browsers block cross-origin requests by default, because otherwise:

A malicious website could secretly call your APIs, steal data, or impersonate users.

Example: Imagine you‚Äôre logged into bank.com. If CORS didn‚Äôt exist, a malicious site hacker.com could run:

fetch("https://bank.com/transfer?to=hacker&amount=1000")


üò± and your money is gone.

So, CORS prevents websites from calling APIs unless the server explicitly allows it.





4. How CORS works (Mechanism)

When frontend calls a backend on a different origin:

Browser first sends a CORS preflight request (an OPTIONS request).

‚ÄúHey server, can I call you from this origin?‚Äù

Server must respond with proper CORS headers, e.g.:

Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization


If the headers match ‚Üí browser allows the actual request.
If not ‚Üí browser blocks the request, and you see error in console:
‚ùå Access to fetch at 'http://localhost:5000/signup' from origin 'http://localhost:3000' has been blocked by CORS policy







‚úÖ 5. How to Fix CORS in Express

That‚Äôs why we use the cors middleware in Express:

Step 1: Install
npm install cors

Step 2: Use in backend
const cors = require("cors");

// Allow all origins (for dev)
app.use(cors());

// Or allow only specific origin
app.use(cors({
  origin: "http://localhost:3000",   // allow only frontend on 3000
  methods: ["GET", "POST"],
  allowedHeaders: ["Content-Type", "Authorization"]
}));







üèóÔ∏è 6. Different Use Cases of CORS
Case A: Development (different ports)

Frontend: http://localhost:3000

Backend: http://localhost:5000

Fix: use app.use(cors({ origin: "http://localhost:3000" }))

Case B: Production (different domains)

Frontend: https://beatnest.com

Backend: https://api.beatnest.com

Fix:

app.use(cors({
  origin: "https://beatnest.com"
}));

Case C: Public API

If you want anyone in the world to use your API (like weather API):

app.use(cors({ origin: "*" }));   // allow all origins


‚ö†Ô∏è But not safe if sensitive data is involved.

Case D: Private API

If only your own frontend should access backend:

app.use(cors({
  origin: ["https://beatnest.com", "https://admin.beatnest.com"]
}));




JSON.STRINGIFY() FUNCTION : When you send data with fetch, the body must be a string (or certain formats like FormData, Blob, etc.).
                            But in JS, { email, password } is an object, not a string.
    { email: "test@gmail.com", password: "12345" }
    ‚Üì JSON.stringify()
    '{"email":"test@gmail.com","password":"12345"}'


üîπ WHAT IS "APPLICATION/JSON" IN HEADERS?

This is the Content-Type header.
It tells the server what format the request body is in.

"application/json" ‚Üí The body is JSON.

"text/plain" ‚Üí The body is plain text.

"application/x-www-form-urlencoded" ‚Üí Form data (like HTML forms).

"multipart/form-data" ‚Üí Used when uploading files.

So in your code:

headers: { "Content-type": "application/json" }


means ‚Üí ‚ÄúHey server, I‚Äôm sending JSON data. Please parse it as JSON.‚Äù





HOW SERVER HANDLES DIFFERENT CONTENT-TYPES : USING MIDDLEWARES
      app.use(express.json());          If it‚Äôs "application/json", it automatically parses the body string back into a JS object.



      What this line actually does
          This is a middleware in Express.
          Middlewares in Express run for every request (GET, POST, PUT, DELETE, etc.) that passes through your server.
          So yes ‚Üí every request passes through this middleware before reaching your route handler.


    üîπ Why do we need it?
          When a request comes in with a JSON body (like your fetch(..., { method: "POST", body: JSON.stringify(...) })), the raw body is just a stream of bytes.
          Without express.json(), if you console.log(req.body), you‚Äôd get undefined because Express doesn‚Äôt parse the body automatically.
          app.use(express.json()); says:
          ‚ÄúWhenever a request has Content-Type: application/json, read the body, parse the JSON, and put the result into req.body.‚Äù




Different Content-Types need different parsers/middlewares on the server side. Let‚Äôs go over the most common ones:


    1. application/json

Use case: APIs sending/receiving structured data.

Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ email: "abc@gmail.com", password: "123" })
});


Server:

app.use(express.json()); // parses JSON into req.body




2. application/x-www-form-urlencoded

Use case: Classic HTML forms (<form method="POST">).

Body looks like:

email=abc%40gmail.com&password=123


Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/x-www-form-urlencoded" },
  body: "email=abc@gmail.com&password=123"
});


Server:

app.use(express.urlencoded({ extended: true }));






3. multipart/form-data

Use case: File uploads (images, audio, video).

Body: Binary + text mixed together in parts.

Client:

const formData = new FormData();
formData.append("username", "abc");
formData.append("profilePic", fileInput.files[0]);

fetch("/upload", { method: "POST", body: formData });


(‚ö†Ô∏è Don‚Äôt set Content-Type manually ‚Üí browser will set boundary automatically.)

Server: Needs a parser like multer, not express.json().




4. text/plain

Use case: Sending raw text.

Client:

fetch("/notes", {
  method: "POST",
  headers: { "Content-Type": "text/plain" },
  body: "This is a plain text note"
});


Server: Use express.text() middleware.



üîπ 5. Others (less common but important)

application/xml ‚Üí XML data (used in legacy APIs).

application/octet-stream ‚Üí Raw binary (files, audio chunks).

application/pdf / image/png ‚Üí Specific file types.






// req and res BUILT-IN OBJECTS IN JS

Exactly üëç ‚Äî you didn‚Äôt define req and res yourself, Express gives them to you automatically.

Let me break it down:


üîπ What are req and res?

When a client (browser, Postman, fetch, etc.) makes a request to your server, Express creates two special objects for you:

req (Request object) ‚Üí Contains everything about the incoming request.

URL
HTTP method (GET, POST, etc.)
Headers
Body (if any)
Query params (?id=123)
Cookies, etc.


res (Response object) ‚Üí Used to send a response back to the client.

res.send() ‚Üí send plain text or HTML
res.json() ‚Üí send JSON
res.status(404).send("Not Found") ‚Üí send status + message
res.redirect() ‚Üí redirect to another URL



üîπ Where do they come from?

Your code:

app.get('/', (req, res) => {
  res.send('Hello World! he he!')
});


Behind the scenes:
    Express sits on top of Node.js‚Äôs HTTP module.
    When a request comes in, Node creates a low-level IncomingMessage (req) and ServerResponse (res).
    Express wraps those in its own Request and Response objects (with extra helpful methods like .json(), .status(), etc.).
    Then, Express passes them to your route handler automatically.
    That‚Äôs why you don‚Äôt need to create req or res ‚Äî they‚Äôre given to your callback.


app.get('/user', (req, res) => {
  console.log(req.method);   // "GET"
  console.log(req.url);      // "/user"
  
  res.status(200).json({ message: "User found!" });
});

req.method ‚Üí comes from the HTTP request.
res.status(200).json(...) ‚Üí Express convenience function to send status + JSON.




FIRST: WHAT IS NODEMAILER VS. TRANSPORT?

Nodemailer = the library (the "engine") that lets you send emails from Node.js.
Transport = the "delivery method" (the "vehicle") Nodemailer uses to actually send the email.
Think of it like

Nodemailer = the post office system (handles packaging, addressing, tracking).
Transport = the mail truck, airplane, or courier service that physically delivers the letter.

So when you use Nodemailer, you always have to pick a transport.

üîπ TYPES OF TRANSPORTS IN NODEMAILER : Transport flexibility ‚Äî SMTP, sendmail, Amazon SES, direct transport, or plugins






DIFFERENCE BETWEEN CRYPTO AND BCRYPT

1. What is crypto?

crypto is a built-in Node.js module (no installation needed).
It provides general-purpose cryptographic functionality like:

Hashing (sha256, sha512, etc.)
Symmetric encryption/decryption (AES, DES, etc.)
Asymmetric encryption (RSA, ECDSA, etc.)
Random value generation

It is fast but not designed specifically for password hashing.
PROBLEM FOR PASSWORDS:
These hashes are deterministic and very fast, so attackers can brute-force millions of guesses per second with precomputed rainbow tables. Not secure for password storage.



üîπ 2. What is bcrypt?

bcrypt is a library (must install: npm install bcrypt).
It is designed specifically for password hashing.

Uses:
Salting (random string added before hashing) ‚Üí prevents rainbow table attacks.
Key stretching (work factor/cost) ‚Üí intentionally slow hashing ‚Üí makes brute-force expensive.



1.1 HASHING FUNCTIONS

üëâ USED FOR DATA INTEGRITY (NOT PASSWORD STORAGE).

import crypto from "crypto";

// SHA-256 hash
const sha256Hash = crypto.createHash("sha256")
  .update("HelloWorld")
  .digest("hex");

console.log("SHA-256 Hash:", sha256Hash);

createHash(algorithm) ‚Üí algorithm can be "sha256", "sha512", etc.
update(data) ‚Üí add data to hash.
digest("hex" | "base64") ‚Üí finalize hash and get result.
‚úÖ Use: File integrity check, digital signatures, API signing.


1.2 HMAC (HASH-BASED MESSAGE AUTHENTICATION CODE)

const secret = "mySecretKey";

const hmac = crypto.createHmac("sha256", secret)
  .update("HelloWorld")
  .digest("hex");

console.log("HMAC:", hmac);

‚úÖ Use: JWT signing, API request signing, ensuring data authenticity.



1.3 RANDOM BYTES

const token = crypto.randomBytes(32).toString("hex");
console.log("Random Token:", token);

‚úÖ Use: Session IDs, password reset tokens, email verification codes.


1.4 SYMMETRIC ENCRYPTION (AES EXAMPLE)

üëâ Encrypt and decrypt data with the same key.

const key = crypto.randomBytes(32);   // 256-bit key
const iv = crypto.randomBytes(16);    // Initialization vector

// Encrypt
const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
let encrypted = cipher.update("HelloWorld", "utf8", "hex");
encrypted += cipher.final("hex");
console.log("Encrypted:", encrypted);

// Decrypt
const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
let decrypted = decipher.update(encrypted, "hex", "utf8");
decrypted += decipher.final("utf8");
console.log("Decrypted:", decrypted);

‚úÖ Use: Encrypting sensitive data (files, messages).


1.5 KEY PAIR (ASYMMETRIC RSA/ECDSA)

üëâ Used for public/private key encryption.

const { generateKeyPairSync } = crypto;

const { publicKey, privateKey } = generateKeyPairSync("rsa", {
  modulusLength: 2048,
});

console.log("Public Key:", publicKey.export({ type: "pkcs1", format: "pem" }));
console.log("Private Key:", privateKey.export({ type: "pkcs1", format: "pem" }));

‚úÖ Use: Digital signatures, SSL/TLS, JWT with RSA.




üîπ 2. BCRYPT (PASSWORD HASHING LIBRARY)

Unlike crypto, bcrypt is only for password hashing.
It‚Äôs slow + salted, making brute force attacks harder.


2.1 HASH A PASSWORD

üëâ Always store passwords hashed.

import bcrypt from "bcrypt";

const password = "mypassword";
const saltRounds = 10;

const hash = await bcrypt.hash(password, saltRounds);
console.log("Hashed Password:", hash);

bcrypt.hash(password, saltRounds)
saltRounds = cost factor (higher = slower = more secure).
‚úÖ Use: Store hashed password in DB.


2.2 VERIFY A PASSWORD

üëâ Compare user input with stored hash.

const isMatch = await bcrypt.compare("mypassword", hash);
console.log("Password Match:", isMatch); // true

‚úÖ Use: Login authentication.


2.3 GENERATE SALT MANUALLY

üëâ You can generate salt separately.

const salt = await bcrypt.genSalt(12);
const hash2 = await bcrypt.hash("mypassword", salt);

console.log("Salt:", salt);
console.log("Hash with salt:", hash2);

‚úÖ Use: More control if you want to manage salt rounds explicitly.

2.4 CHANGE SALT ROUNDS FOR SECURITY

üëâ Increasing rounds makes hashing slower but more secure.

const hashFast = await bcrypt.hash("mypassword", 8);  // faster
const hashSlow = await bcrypt.hash("mypassword", 15); // slower, more secure

console.log("Fast Hash:", hashFast);
console.log("Slow Hash:", hashSlow);

‚úÖ Use: Adjust performance vs security tradeoff.





EXPRESS RESPONSE METHODS

1. res.status(code)

  Sets the HTTP status code (like 200 OK, 400 Bad Request, 404 Not Found, 500 Server Error, etc.).
  Usually chained with another method like .send(), .json(), .end().
  Use case: Always when you want to indicate success/failure explicitly.

res.status(404).send("Not Found");


2. res.send([body])

Sends a response body of any type (string, object, array, buffer, HTML).
If you pass an object/array, Express automatically converts it to JSON.
If you pass a string, it sends plain text/HTML.

res.send("Hello World");         // plain text
res.send("<h1>Hello</h1>");      // HTML response
res.send({ user: "Jarvis" });    // JSON automatically

Use case: When you want flexibility (text, HTML, JSON).



3. res.json(obj)

Sends a JSON response.
Automatically sets Content-Type: application/json.

Useful for APIs.

res.json({ success: true, data: [1, 2, 3] });

Use case: REST APIs or AJAX calls from frontend.



4. res.sendFile(path)

Sends a file as the response.
Example: Serving images, PDFs, or downloadable files.

res.sendFile("/absolute/path/to/image.png");

Use case: File downloads, serving static files dynamically.




5. res.download(path, [filename])

Forces the browser to download a file instead of displaying it.
Optional filename lets you rename it.

res.download("/files/report.pdf", "user-report.pdf");

Use case: Letting users download generated files.




6. res.redirect([status,] url)

Redirects the client to another URL.
Default status is 302 (Found ‚Üí temporary redirect).

res.redirect("/login");           // 302 redirect
res.redirect(301, "/new-page");   // permanent redirect

Use case: After logout, redirecting users to /login.



7. res.end([data])

Ends the response process immediately.
Can send optional data (like raw strings/buffers).

res.end();             // just end response
res.end("Done!");      // end with message

Use case: Low-level response finishing, no content needed.



8. res.render(view, [locals])

Used with template engines (like EJS, Pug, Handlebars).
Renders HTML from a template.

res.render("profile", { username: "Jarvis" });

Use case: Server-side rendered apps.



9. res.set(field, value)

Sets a custom header.

res.set("X-Powered-By", "Jarvis");
res.status(200).send("Header set!");

Use case: Custom metadata (security headers, caching, API versioning).



10. res.cookie(name, value, [options]) & res.clearCookie(name)

Send or clear cookies with the response.

res.cookie("token", "12345", { httpOnly: true });
res.clearCookie("token");

Use case: Session handling, authentication.



HELMET PACKAGE : The Helmet package is a security middleware for Express.js applications. Its main purpose is to help protect 
                 your app from common web vulnerabilities by setting secure HTTP headers automatically.


Sets Secure HTTP Headers

It configures headers like:

Content-Security-Policy (CSP) ‚Üí Prevents cross-site scripting (XSS) and other code injection attacks.
X-Frame-Options ‚Üí Prevents clickjacking by disallowing embedding of your site in iframes.
Strict-Transport-Security (HSTS) ‚Üí Forces HTTPS connections.
X-Content-Type-Options ‚Üí Prevents browsers from guessing ("sniffing") content types.
X-DNS-Prefetch-Control ‚Üí Controls DNS prefetching.
X-Permitted-Cross-Domain-Policies ‚Üí Restricts Adobe Flash/Acrobat cross-domain policies.
Referrer-Policy ‚Üí Controls how much referrer info is shared.
Cross-Origin-Embedder-Policy, Cross-Origin-Opener-Policy, Cross-Origin-Resource-Policy ‚Üí Strengthen isolation and mitigate cross-origin leaks



Explanation of some Helmet headers (with examples)

X-Frame-Options: SAMEORIGIN:
Prevents your site from being loaded in an iframe on another site (stops clickjacking attacks).
Example: If an attacker tries to embed your banking site in their page and trick you into clicking ‚ÄúTransfer money‚Äù, this header blocks it.

X-Content-Type-Options: nosniff:
Prevents browsers from guessing file types.
Example: If your server says a file is text/plain, but it actually contains JavaScript, the browser won‚Äôt execute it. This prevents some XSS attacks.

Strict-Transport-Security:
Forces all future requests to use HTTPS, not HTTP.
Example: If someone types http://example.com, the browser will auto-upgrade to https://example.com.

Referrer-Policy: no-referrer:
Controls how much referrer info is shared when a user clicks a link.
Example: If you visit mybank.com, and then click a link to evil.com, your bank URL won‚Äôt be leaked as the referrer.

Content-Security-Policy (CSP):
Controls what kind of content (scripts, images, styles) can load on your site.
Example: You can allow scripts only from your own domain (self), blocking malicious scripts injected from others.







// TIME LIMITER PACKAGE    :    express-rate-limit is middleware that tracks requests per IP.
The rate-limit (or more commonly express-rate-limit) package is used to control the rate of incoming requests to your server.

// Create a rate limiter middleware
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes(15*60*1000 miliseconds = 15 minutes)
  max: 100,                  // Limit each IP to 100 requests per window
  message: "Too many requests from this IP, please try again later."
});
app.use(limiter);



// EXPLAINATION : windowMs: 15 * 60 * 1000
                  This defines the time window for counting requests.
                  15 * 60 * 1000 = 900,000 milliseconds = 15 minutes.
                  Meaning: the server counts requests per IP in 15-minute intervals.
                  After 15 minutes, the counter resets.

*******This means a particular IP(let duggal's IP) can send 100 maximum requests in 15 minute time window
       This 100req/15min is applicable on each address(IP) separately
       If User A (with IP 123.45.67.1) sends requests ‚Üí their counter is separate.
       If User B (with IP 223.45.67.2) sends requests ‚Üí they have a different counter.

       If count > 100 ‚Üí Express stops processing and sends back 429 Too Many Requests.


// USE CASES

    Login routes ‚Üí prevent brute-force attacks.
    APIs with free tiers ‚Üí allow 100 requests/hour for free users.
    Expensive operations ‚Üí like file uploads, password resets, or payments.
    Prevent scraping or spam ‚Üí by limiting excessive requests from bots.




// IMPORTANT NOTE : 

Proxies / Load Balancers:
If your app is behind something like Nginx, Cloudflare, or Heroku, the default IP detected may actually be the proxy‚Äôs IP (not the real user).

To fix this, you need:     app.set("trust proxy", 1);
This tells Express to look at headers (X-Forwarded-For) to get the real client IP.



Case 1: Simple server (no proxy)
If you just run your Express app on localhost or on a VPS (like DigitalOcean, AWS EC2), then:
A user visits your site.
The request comes directly to your Node/Express server.
Express can see the real IP of the user (123.45.67.8 etc.).
express-rate-limit works fine out of the box.



üèóÔ∏è Case 2: Behind a proxy / load balancer / CDN
In production, most websites are not directly exposed. They sit behind another server (proxy). Examples:
Nginx / Apache ‚Üí reverse proxy (commonly used).
Heroku ‚Üí has its own routing layer.
Vercel / Netlify ‚Üí sit in front of your Node app.
Cloudflare ‚Üí CDN + security proxy.

üëâ What happens then?

The user‚Äôs request first hits the proxy (e.g., Cloudflare or Nginx).
That proxy then forwards the request to your Node app.
To your Express app, the request looks like it came from the proxy‚Äôs IP, not the real user.

Example:
Real user IP = 123.45.67.8
But Express sees only: 10.0.0.5 (the IP of your Nginx proxy).
So if you don‚Äôt fix this, all requests might look like they are coming from the same IP, and rate limiting will be useless.

Fix: app.set("trust proxy", 1)
This line tells Express:
‚ÄúHey, I know I‚Äôm behind a proxy. Please don‚Äôt use the proxy‚Äôs IP. Instead, look at the special X-Forwarded-For header that proxies set, which contains the real client IP.‚Äù

‚úÖ Summary:
If your app runs directly ‚Üí you see real IPs (no problem).
If your app runs behind Cloudflare/Heroku/Nginx/etc. ‚Üí you need app.set("trust proxy", 1) so Express can get the real IP.



üåç Why can‚Äôt a request just hit your server.js directly?

Because when you deploy to cloud platforms (like Vercel, Heroku, Netlify, etc.), your app is not exposed directly to the internet. Instead, these platforms put a proxy layer in front of your app for several reasons:

üîë Reasons why proxies exist in front of your server:

Security
If your Node server was directly exposed, attackers could scan and exploit it more easily.
Proxies act as a shield between the public internet and your app.

Load Balancing
Big platforms don‚Äôt run just one server.js file.
They run multiple copies (instances) of your app across many machines.
The proxy decides which instance gets each incoming request.
Without the proxy, you‚Äôd need to manually manage routing between many servers.

SSL / HTTPS Handling
TLS/SSL (the ‚Äúhttps://‚Äù part) is usually terminated at the proxy.
That means the proxy handles all encryption/decryption, so your app only deals with plain HTTP internally.
This reduces CPU load on your app and centralizes certificate management.

Caching & CDN
Platforms like Vercel or Cloudflare can cache static assets (images, CSS, JS) at the proxy level.
This makes them serve content much faster without hitting your server.
Without proxies, every request (even static files) would reach your app ‚Üí more load.

Multi-region deployments
If your users are worldwide, Vercel‚Äôs proxies/CDN nodes are everywhere.
A user in India hits a proxy in Mumbai.
That proxy decides whether to serve cached data or forward the request to your nearest app server.
Without the proxy, every request would have to travel to wherever your app is hosted ‚Üí slow.

1. PUBLIC VS PRIVATE ADDRESS
On Vercel (or AWS, GCP, etc.), your app is given one public address (like yourapp.vercel.app).
But behind the scenes, there are many machines (servers) running copies of your app.
Each machine has its own private/internal address, but the public never sees those.

So from the outside world:
üëâ Everyone connects to yourapp.vercel.app.
üëâ The proxy/load balancer decides which machine actually handles the request.

THE ROLE OF THE LOAD BALANCER
The ‚Äútrick‚Äù that makes this possible is the load balancer (a type of proxy).
Think of it like a receptionist in a company:
The company has one phone number (public address).
Behind the receptionist, there are 100 employees (servers).
When someone calls the number, the receptionist decides which employee should take the call.

DNS MAGIC ‚ú®
When someone types yourapp.vercel.app, DNS always resolves to the load balancer‚Äôs IP (not the actual server where your Node code runs).
The load balancer then forwards requests internally to whichever machine is free/near.
So users never see the private IPs of your app instances. They only see the one public address.

Similarly:
Your app has one domain name (yourapp.vercel.app).
The load balancer receives all requests.


WHAT IS A CDN?

A Content Delivery Network (CDN) is a geographically distributed network of servers that work together to deliver internet content (like HTML, CSS, JS, images, videos, fonts, etc.) to users faster, more reliably, and more securely.

Instead of every request hitting your origin server (where your website/app is hosted), a CDN caches and serves content from servers located closer to the user (called edge servers).

It forwards each request to one of the many running app instances (on different machines).
Enterprise / Distributed Apps:
If you run your app on multiple servers (behind a load balancer), you‚Äôll want to use a shared store like Redis or Memcached for rate-limiting. Otherwise, each server tracks requests separately, and users could bypass limits by hitting different servers.


4Ô∏è‚É£ DNS (DOMAIN NAME SYSTEM)

DNS is like the phonebook of the Internet.
Converts human-readable domain names (like example.com) into IP addresses (like 123.45.67.89) that computers use to route traffic.

üîß How DNS works (simplified)
User types example.com in browser.
Browser asks DNS resolver ‚Üí ‚ÄúWhat‚Äôs the IP of example.com?‚Äù
Resolver finds the IP (through hierarchy: root ‚Üí TLD ‚Üí authoritative server).
Browser connects to that IP ‚Üí request reaches the server.

‚úÖ Uses
Makes the web human-friendly (we remember google.com, not 142.250.190.14).
Allows load balancing (multiple IPs for same domain).
Enables CDNs to route users to nearest edge server.

1Ô∏è‚É£ REDIS

Redis is an in-memory data store. Think of it as a super fast database that stores data in RAM instead of disks, so reading/writing is extremely quick.

‚úÖ Key Points

Stores data in memory ‚Üí very fast (microseconds).
Supports key-value pairs, but also advanced structures: lists, sets, hashes, sorted sets, bitmaps, etc.
Can persist data to disk (optional), but main use is caching and fast data access.
Often used as a shared store for multiple app instances.

üîß Uses
Caching ‚Üí store frequently accessed data to reduce database load.
Example:    Store user session info or API responses in Redis instead of querying DB every time
Rate limiting ‚Üí store request counts per user/IP across multiple servers.
Message queues / pub-sub ‚Üí apps can communicate asynchronously.
Real-time analytics ‚Üí counters, leaderboards, activity tracking.
