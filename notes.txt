üåç 1. What is CORS?

CORS = Cross-Origin Resource Sharing.
It‚Äôs a security mechanism built into browsers to control how a web page (frontend) can request resources (API, data, images, etc.) from a different origin.


2. What is an "Origin"?

Origin = combination of protocol + domain (or IP) + port.

Examples:

http://localhost:3000 ‚Üí origin = http + localhost + 3000

http://localhost:5000 ‚Üí origin = http + localhost + 5000

https://beatnest.com ‚Üí origin = https + beatnest.com + 443

üëâ Even if domain is same but port is different, it‚Äôs a different origin!
So:

http://localhost:3000 and http://localhost:5000 ‚Üí different origins ‚ùå

https://beatnest.com and http://beatnest.com ‚Üí different origins ‚ùå

https://beatnest.com/api and https://beatnest.com/home ‚Üí same origin ‚úÖ (path doesn‚Äôt matter)





3. Why does CORS create problems?

Browsers block cross-origin requests by default, because otherwise:

A malicious website could secretly call your APIs, steal data, or impersonate users.

Example: Imagine you‚Äôre logged into bank.com. If CORS didn‚Äôt exist, a malicious site hacker.com could run:

fetch("https://bank.com/transfer?to=hacker&amount=1000")


üò± and your money is gone.

So, CORS prevents websites from calling APIs unless the server explicitly allows it.





4. How CORS works (Mechanism)

When frontend calls a backend on a different origin:

Browser first sends a CORS preflight request (an OPTIONS request).

‚ÄúHey server, can I call you from this origin?‚Äù

Server must respond with proper CORS headers, e.g.:

Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization


If the headers match ‚Üí browser allows the actual request.
If not ‚Üí browser blocks the request, and you see error in console:
‚ùå Access to fetch at 'http://localhost:5000/signup' from origin 'http://localhost:3000' has been blocked by CORS policy







‚úÖ 5. How to Fix CORS in Express

That‚Äôs why we use the cors middleware in Express:

Step 1: Install
npm install cors

Step 2: Use in backend
const cors = require("cors");

// Allow all origins (for dev)
app.use(cors());

// Or allow only specific origin
app.use(cors({
  origin: "http://localhost:3000",   // allow only frontend on 3000
  methods: ["GET", "POST"],
  allowedHeaders: ["Content-Type", "Authorization"]
}));







üèóÔ∏è 6. Different Use Cases of CORS
Case A: Development (different ports)

Frontend: http://localhost:3000

Backend: http://localhost:5000

Fix: use app.use(cors({ origin: "http://localhost:3000" }))

Case B: Production (different domains)

Frontend: https://beatnest.com

Backend: https://api.beatnest.com

Fix:

app.use(cors({
  origin: "https://beatnest.com"
}));

Case C: Public API

If you want anyone in the world to use your API (like weather API):

app.use(cors({ origin: "*" }));   // allow all origins


‚ö†Ô∏è But not safe if sensitive data is involved.

Case D: Private API

If only your own frontend should access backend:

app.use(cors({
  origin: ["https://beatnest.com", "https://admin.beatnest.com"]
}));




JSON.STRINGIFY() FUNCTION : When you send data with fetch, the body must be a string (or certain formats like FormData, Blob, etc.).
                            But in JS, { email, password } is an object, not a string.
    { email: "test@gmail.com", password: "12345" }
    ‚Üì JSON.stringify()
    '{"email":"test@gmail.com","password":"12345"}'


üîπ WHAT IS "APPLICATION/JSON" IN HEADERS?

This is the Content-Type header.
It tells the server what format the request body is in.

"application/json" ‚Üí The body is JSON.

"text/plain" ‚Üí The body is plain text.

"application/x-www-form-urlencoded" ‚Üí Form data (like HTML forms).

"multipart/form-data" ‚Üí Used when uploading files.

So in your code:

headers: { "Content-type": "application/json" }


means ‚Üí ‚ÄúHey server, I‚Äôm sending JSON data. Please parse it as JSON.‚Äù





HOW SERVER HANDLES DIFFERENT CONTENT-TYPES : USING MIDDLEWARES
      app.use(express.json());          If it‚Äôs "application/json", it automatically parses the body string back into a JS object.



      What this line actually does
          This is a middleware in Express.
          Middlewares in Express run for every request (GET, POST, PUT, DELETE, etc.) that passes through your server.
          So yes ‚Üí every request passes through this middleware before reaching your route handler.


    üîπ Why do we need it?
          When a request comes in with a JSON body (like your fetch(..., { method: "POST", body: JSON.stringify(...) })), the raw body is just a stream of bytes.
          Without express.json(), if you console.log(req.body), you‚Äôd get undefined because Express doesn‚Äôt parse the body automatically.
          app.use(express.json()); says:
          ‚ÄúWhenever a request has Content-Type: application/json, read the body, parse the JSON, and put the result into req.body.‚Äù




Different Content-Types need different parsers/middlewares on the server side. Let‚Äôs go over the most common ones:


    1. application/json

Use case: APIs sending/receiving structured data.

Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ email: "abc@gmail.com", password: "123" })
});


Server:

app.use(express.json()); // parses JSON into req.body




2. application/x-www-form-urlencoded

Use case: Classic HTML forms (<form method="POST">).

Body looks like:

email=abc%40gmail.com&password=123


Client:

fetch("/signup", {
  method: "POST",
  headers: { "Content-Type": "application/x-www-form-urlencoded" },
  body: "email=abc@gmail.com&password=123"
});


Server:

app.use(express.urlencoded({ extended: true }));






3. multipart/form-data

Use case: File uploads (images, audio, video).

Body: Binary + text mixed together in parts.

Client:

const formData = new FormData();
formData.append("username", "abc");
formData.append("profilePic", fileInput.files[0]);

fetch("/upload", { method: "POST", body: formData });


(‚ö†Ô∏è Don‚Äôt set Content-Type manually ‚Üí browser will set boundary automatically.)

Server: Needs a parser like multer, not express.json().




4. text/plain

Use case: Sending raw text.

Client:

fetch("/notes", {
  method: "POST",
  headers: { "Content-Type": "text/plain" },
  body: "This is a plain text note"
});


Server: Use express.text() middleware.



üîπ 5. Others (less common but important)

application/xml ‚Üí XML data (used in legacy APIs).

application/octet-stream ‚Üí Raw binary (files, audio chunks).

application/pdf / image/png ‚Üí Specific file types.






// req and res BUILT-IN OBJECTS IN JS

Exactly üëç ‚Äî you didn‚Äôt define req and res yourself, Express gives them to you automatically.

Let me break it down:


üîπ What are req and res?

When a client (browser, Postman, fetch, etc.) makes a request to your server, Express creates two special objects for you:

req (Request object) ‚Üí Contains everything about the incoming request.

URL
HTTP method (GET, POST, etc.)
Headers
Body (if any)
Query params (?id=123)
Cookies, etc.


res (Response object) ‚Üí Used to send a response back to the client.

res.send() ‚Üí send plain text or HTML
res.json() ‚Üí send JSON
res.status(404).send("Not Found") ‚Üí send status + message
res.redirect() ‚Üí redirect to another URL



üîπ Where do they come from?

Your code:

app.get('/', (req, res) => {
  res.send('Hello World! he he!')
});


Behind the scenes:
    Express sits on top of Node.js‚Äôs HTTP module.
    When a request comes in, Node creates a low-level IncomingMessage (req) and ServerResponse (res).
    Express wraps those in its own Request and Response objects (with extra helpful methods like .json(), .status(), etc.).
    Then, Express passes them to your route handler automatically.
    That‚Äôs why you don‚Äôt need to create req or res ‚Äî they‚Äôre given to your callback.


app.get('/user', (req, res) => {
  console.log(req.method);   // "GET"
  console.log(req.url);      // "/user"
  
  res.status(200).json({ message: "User found!" });
});

req.method ‚Üí comes from the HTTP request.
res.status(200).json(...) ‚Üí Express convenience function to send status + JSON.